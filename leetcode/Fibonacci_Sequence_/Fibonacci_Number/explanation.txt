Here's a step-by-step explanation of the code:

**Class and Method Definition**

The code defines a class `Solution` with a method `fib` that takes an integer `n` as input and returns an integer.

**Method Logic**

The method calculates the `n`-th Fibonacci number using an iterative approach. Here's a breakdown of the steps:

1. **Base Case**: If `n` is 0, the method returns 0, which is the base case for the Fibonacci sequence.
2. Initialize variables:
	* `prevprev` is set to 0, which will store the previous previous Fibonacci number.
	* `prev` is set to 1, which will store the previous Fibonacci number.
3. **Loop**: The method enters a loop that runs from `i = 2` to `i = n`. This loop generates the Fibonacci sequence starting from the second number (1).
4. **Calculate the Current Fibonacci Number**: In each iteration, the method calculates the current Fibonacci number `curr` as the sum of the previous previous Fibonacci number `prevprev` and the previous Fibonacci number `prev`.
5. **Update the Previous Values**: After calculating the current Fibonacci number, the method updates the previous values by setting `prevprev` to the previous value of `prev` and `prev` to the current value of `curr`.
6. **Return the Result**: After the loop finishes, the method returns the final value of `prev`, which is the `n`-th Fibonacci number.

**Example**

If `n` is 5, the method will calculate the Fibonacci sequence as follows:

* `prevprev` = 0, `prev` = 1 ( initialization )
* `i = 2`: `curr` = 0 + 1 = 1, `prevprev` = 1, `prev` = 1
* `i = 3`: `curr` = 1 + 1 = 2, `prevprev` = 1, `prev` = 2
* `i = 4`: `curr` = 1 + 2 = 3, `prevprev` = 2, `prev` = 3
* `i = 5`: `curr` = 2 + 3 = 5, `prevprev` = 3, `prev` = 5
* Return `prev` = 5 as the 5th Fibonacci number.

The method's time complexity is O(n), making it more efficient than recursive approaches for large values of `n`.